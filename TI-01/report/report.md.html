<meta charset="utf-8" lang="pt">

                                    **Geração de Números Primos**
                                **INE5429 - Segurança em Computadores**
                                        Trabalho Individual #1
                                *Quenio Cesar Machado dos Santos (14100868)*
                                        Florianópolis, 08/05/2016

# Introdução

Neste trabalho vamos investigar e implementar a geração de números primos por um computador.

A geração de números primos pode ser dividida em dois passos:
- A geração de números aleatórios.
- A verificação se os números gerados são primos ou não.

Na próxima seção, vamos investigar a geração de números aleatórios. Posteriormente, vamos abordar a verificação de *primalidade* dos números gerados.

# Números Pseudo-Aleatórios

Uma sequência de números aleatórios pode ser gerada automaticamente por um computador. Existem algoritmos desenvolvidos para esta finalidade que são chamados de *geradores de números pseudo-aleatórios*.

As sequências resultantes destes geradores não são verdadeiramente aleatórias. Estas são geradas a partir de um grupo pequeno de valores iniciais - chamados sementes. Porém, alguns dos valores sementes podem ser verdadeiramente aleatórios. Por exemplo, eles podem originar-se do relógio do próprio computador ou ainda de ruídos da câmera de vídeo e do microfone.

O *período* dos algoritmos - o tamanho da sequência gerada sem repetição - também são normalmente muito longos. O que na prática permite a utilização destes algoritmos em aplicações que necessitam de uma fonte geradora de números aleatórios, tais como *criptografia*.

Existem vários métodos disponíveis para a implementação de geradores de números pseudo-aleatórios. Nas próximas seções, vamos utilizar um dos métodos para implementar um gerador na linguagem *C*. Esta linguagem de programação permite a operação de números de precisão variável - através da biblioteca *GMP* - e também gera código de máquina muito eficiente.

## O Método `xorshift`

O método escolhido para a geração de números pseudo-aleatórios é `xorshift`. Este utiliza operações `XOR` e *bit-shift* para gerar novos números a partir de números anteriores.

Algoritmos implementados com `xorshift` executam muito rapidamente, pois utilizam operações implementadas por instruções do processador do computador que precisam de poucos *ciclos*. Entretanto, os parâmetros - valores sementes e constantes usados nas operações -  precisam ser escolhidos com cuidado para permitir longos períodos sem repetição de números.

Na sua forma original, o método `xorshift` não é adequado para uso em criptografia, pois não gera períodos muito longos. Mas este pode facilmente ser melhorado com o uso de uma operação de soma ou multiplicação. Estas variações são denominadas respectivamente de `xorshift+` e `xorshift*`.

Na próxima seção, vamos listar e comentar o código-fonte da implementação de `xorshift+` desenvolvida neste trabalho.

## A Implementação

O método `xorshift` exige uma sequência inicial de números - as sementes - a serem utilizadas para a geração dos números. Quanto maior o número de sementes, mais longo será o período do gerador.

Na implementação abaixo, utilizamos um vetor de 16 inteiros de 64 bits, que permite um período máximo de $2^{1024} - 1$:

~~~~~~~~~~~~~~~
static const size_t s_size = 16;
static const uint64_t seed[s_size] = {
    UINT64_C(3176816624292027912),
    UINT64_C(5825261852996363023),
    UINT64_C(2657966707352449287),
    UINT64_C(1350174793163142913),
    UINT64_C(3916890652982003621),
    UINT64_C(8441565361753670199),
    UINT64_C(4048287511883088063),
    UINT64_C(7692991216032604145),
    UINT64_C(9168990544929416867),
    UINT64_C(4210552781383542944),
    UINT64_C(1295553278952537540),
    UINT64_C(4600491088959978208),
    UINT64_C(1426091184381835091),
    UINT64_C(2349336915254555439),
    UINT64_C(2525507937445642803),
    UINT64_C(4828313259052508846)
};
~~~~~~~~~~~~~~~

Se utilizarmos as sementes tais quais elas foram definidas acima, nosso gerador irá sempre gerar a mesma sequência de números em cada nova execução do programa. Para tornar a sequência variável entre execuções, utilizados o relógio do computador para gerar novas sementes, como implementado abaixo:

~~~~~~~~~~~~~~~
void init_seed(uint64_t *s)
{
    for (int i = 0; i < s_size; i++)
    {
         s[i] = clock() + seed[i];
    }
}
~~~~~~~~~~~~~~~

Observe no código-fonte acima que o tempo em nanoseconds do relógio é somado ao valor inicial da semente para gerar uma nova semente, diferente em cada execução do programa. Estas novas sementes é que realmente serão utilizadas pelo algoritmo gerador, implementado a seguir:

~~~~~~~~~~~~~~~
// xorshift+ 1024-bit
uint64_t random_int64()
{
    // Posição atual no vetor de sementes:
    static size_t i = 0;

    // Inicializa sementes somente na primeira execução desta função:
    static uint64_t s[s_size];
    if (s[i] == 0) init_seed(s);

    // Estabelece os valores de semente a serem usados nesta geração:
    uint64_t s0 = s[i];
    uint64_t s1 = s[i = (i + 1) & (s_size - 1)];
    const uint64_t ps1 = s1;

    // Gera o novo número usando shifts e xor:
    s1 ^= s1 << 31;
    s[i] = s1 ^ s0 ^ (s1 >> 11) ^ (s0 >> 30);

    // Usa a soma para aumentar a aleatoriedade desta função:
    return s[i] + ps1;
}
~~~~~~~~~~~~~~~

Agora, a função implementada acima nos permite gerar sequências pseudo-aleatórias de inteiros de 64 bits. Para gerar números com maior número de bits, utilizamos o gerador e concatenamos seus números em números maiores:

~~~~~~~~~~~~~~~
static inline size_t div_ceiling(size_t op1, size_t op2)
{
    return 1 + ((op1 - 1) / op2);
}

void random_mpz(mpz_t rop, size_t bit_count)
{
    static const size_t byte_bit_count = 8;

    // Geração dos componentes do número:
    size_t size = div_ceiling(bit_count, byte_bit_count);
    size_t count = div_ceiling(size, sizeof(int64_t));
    uint64_t n[count];
    for (int i = 0; i < count; i++) n[i] = random_int64();

    // Se o número for maior que 64 bits, precisamos do vetor inteiro:
    static const size_t int64_bit_count = (sizeof(int64_t) * byte_bit_count);
    if (bit_count >= int64_bit_count)
    {
        mpz_init_set_int64(rop, count, n);
    }
    else
    {
        // Caso seja menos de 64 bits, capturamos apenas parte do número gerado:
        const size_t ignored_bits = (int64_bit_count - bit_count);
        mpz_init_set_ui(rop, n[0] >> ignored_bits);
    }
}
~~~~~~~~~~~~~~~

Observe então que a função gera números de precisão arbitrária, usando o gerador de 64 bits como base. A próxima mostra a execução do gerador.

## A Execução

O código-fonte abaixo permite gerar números aleatórios de 128 bits, 256, 512, e assim sucessivamente, até 4096 bits:

~~~~~~~~~~~~~~~
int main()
{
    static const int base = 10;
    static const size_t max_bit_count = 4096;
    static const size_t bit_count_inc = 128;

    const clock_t start = clock();

    size_t bit_count = bit_count_inc;
    while (bit_count <= max_bit_count)
    {
        const clock_t s = clock();

        mpz_t n;
        random_mpz(n, bit_count);

        printf("%-4lu (t = %10.6lf)", bit_count, elapsed_secs(s));
        printf(" -> ");
        mpz_out_str(NULL, base, n);
        printf("\n");

        bit_count += bit_count_inc;
    }

    printf("\nTotal Time: %lf\n", elapsed_secs(start));

    return 0;
}
~~~~~~~~~~~~~~~

Abaixo, temos a saída do programa:

~~~~~~~~~~~~~~~
128  (t =   0.000019) -> 165257786787652276919289564940747825877
256  (t =   0.000002) -> 84865960580376472255847981412862837933171166611691443137137826841849840471803
384  (t =   0.000000) -> 3185221734447230588445717933477513668944082219102809735452988238554260768096117447220023425928235956509670004770644
512  (t =   0.000001) -> 8877219353487259678642396619196080092858056481159989830635913716278901324439100183551291681772514852692118032268996594744122355570548783200752610362776460
640  (t =   0.000001) -> 1491504433694245535722790466900130620604684404930826254211937905516955330782645783333616379842598088688561195796286957479527246857973219911726731280451254323686908719562803033540338745150907774
768  (t =   0.000001) -> 880953833576092572494682063046585776849672763475671339274569273684088771037272314379425807339024529219519674615792804033717210725126847695756457303469411780851331321421054123319825195086343437208735620127378038664452222158677012509
896  (t =   0.000000) -> 397589189942653872656205776624073401939744768680759493355060878280440782756740064812680038144038663089467082117674958187338941481447860126739628775642415389645588979699888660201617862408702925292678824574650758766111775848075282842331206561883806207921604052126231942646
1024 (t =   0.000029) -> 123191853070866442593902125059454327682333247628418493350804260684708665369074982608366542565601573018130585699064951882046895743751880138295410255218678460772356961704245633862906590547923666549541613954058909130823203111023430517133798250939611994027741429847824445717199615137099007156801880194670575767381
1152 (t =   0.000003) -> 40424975074552161332138947969217701946379649662984038698333494515943107836466726315664016099783955205631020543062697818218960976759964814132045513856753145507124280630533881291785884191026575832877198363701495941544954751209389008258762754522055083424713535117075284148210692465332953842445780937264892803695635577732285711663776861523670017488751
1280 (t =   0.000001) -> 7290542599136670422735130325965822244374588898878283161400086713232128508563440900588897288424158830828293366071926207321576489481695050600311989662309048417568177896319256212392678368629223105098343961832853454206955582906538318008140829038383448881537690711991648830934112133487754397728836481482544498187218035282300646044547210803474426241587102536428097772607607639709381664378089
1408 (t =   0.000011) -> 5783922548818019684940715086065026229089256240269131273293681991318460926624933412150526392397231486720813544797964032665474167303648390557202329982205326497626505472801797345742285580643754721328719829901915854939177495243663825055667457116890693989199207670781589648358288021491776669779655485958821442920297073094269090458083149440316077008738672439199547960449905427964661201152259335072689768046037292995176463506009879
1536 (t =   0.000002) -> 97912120165776148897339863372206591380114367482332189273014390381299243534883741894662432835992661453409700375863064097587763577699206410918879449624930996666018147271485428613647668429208167877087016796846699659025460195294602934599816761534208081156081858595267387569838751886539922018409753252302852772256479782445296334049877570596617400173793689626766215894502441916574703344812236261720189161827767760943719382513578688014976586030492000308397151927568851
1664 (t =   0.000026) -> 760591869253559739024939464689271294508870225807638598363170538873733738459610881562312800552768822126126642976983890029399147905912878818460369136535877244872562654690342931666058835206168276760089416448639243101130851064658889525851057313255354026339435993850695687996019952620413621029439226107838139750280851355467926818443650184338848189791345827975742035691381771278730874696422430724942143829775452072119588749363874964984779413584459775917995049444676435543971936325142389517935724091327655577
1792 (t =   0.000005) -> 186699622236846921351300905743913674320286084435012634373073112737390499060029943777652083778181977098041185397718011951640969731673737287961738252367841743477495171595859678403361616960742087836874723295583185246389277205456131558630050150224364372943981784182081686613328068149771846684636311733173875065227059936810592993916330279732711307348010205444850174969199366144294155102441795216904261343569156161794989491049346407219078549449002760692995824647689224318128502496200427380711808065565318627034197574229409051129911941143789470460
1920 (t =   0.000051) -> 89941163084660163416986362863848127388581928062768504325038488443595241378467503938069052694713805029852839026879911249646470835172750975151562464057679102565034280876425821801727948743132179146435710825421555785421287422563237590140578020223247171848043529479322269350039568723952450702413809482762094950090415420424170380969372572562460821043945136340937561160900704256748977789419427641191889980291363582318023641824420594909880125820029988366357629009284815872364179738624402471529383875684518974937052262131215413482377823232480952961298909873397557043944048099586572718879
2048 (t =   0.000004) -> 25363877649607935128678164449238574449818980565663387350943681717906670621386378902714959229910386441761679705063009441535025226249163535002112549289486861533878814512678059847736159938220038919633368972877138841088992061456646178625088020488375244460346502189781358472239877155790351973637074678583114476536855140001248940639305413574552529932377895125585543494566010962053688462423628641829036221371565876619412784428385565224915838148409872649101843200776588318383715042386138693774847441426469189442690755419479766015990813252078174522004088866179163344898951586246041731797930620765336549615496874762841375453675
2176 (t =   0.000013) -> 1805970065318697363381843476251641608938722038102354005293817341090289902673993449941935132629896951482156332206855726162487133420013653387260265159537608122014310332062909150967314736854541610211566748969310210571385457486161521786047290835703537484605626676787671346644700745816463585249695982904623096258423144460486953346914036509371432989098378257286879410652035904150566851284765777459876525085488817493411875028096906966850485370946161421207581645763303744273120491533283922546193811114402878002084978669291567244323710506528051989295189572629535390658819805770243718752334654541930296814252994880145337910141037460849939255739623387204654423630493
2304 (t =   0.000009) -> 3221059760096651761341977505961815990190930962280967822592987559878753056816651698628314045254064288080385305338670934689328580025309850484945748101100577562148257267150402358342681785823801477784957979468284769282294254141576116283848596823231115226313826580743977225353202174310691199787476898257698364128332747269275146084973734502541022580411679152252699795816794049510764988047802983430954678045147766139854751154848662085235139992943882839730852302141462758619362266799873131332756909777524968748814268910343183690055175247851309177188171894363284074914205751212237246991937973796434977597408895015086210144545361014017052877214522339622499287915564256619781682903645472662274530021408678
2432 (t =   0.000003) -> 47210658455954646649506082454614632610264956973995850885590199912846776352526283070649834053102793431131727836632034020307929655932928285861444587879347078123126765186496449207361959902472878486902537357642923338316189452689591534846638926683576191651474871209216912944410590754092363309664289834661045078543706695887655086489710326390374161023889424318203084387671803839045901873108935764436057596712709680740486953451037539463420074088068472706840605563061725440315434820941390912456134642332159057982505282913912028721328085076868869454161341341135905436934934210734488349421553377368039794930897886304590571695358952349665517920305179099185799071270028319522324362920120135170838298689445573052361196924914616297796645586827811
2560 (t =   0.000011) -> 184095088371930912117337315201713621905025450158381776587918396351050214992870994928266707240265401674779884332841062320832647269485875130108039341341942391963300174494791138392569438598629444044382101450831865367415570301644586201170562165004572184371951194607785034059005714234343827005680035539216820592221514283806691321463689681269434433759246060729205752905934765870638013927831235489896201890284508232301525669638300877113924851434711495353496438510320357297820320575341517954686184598840981666105355011466787844230331100731623819577068227142866958566953019602375028734966828291170685238162496721396799438705846705385285404883668641813076738971516111691953907991611517236032444993882043299698005723144255604725808667709168219558842148351875392861588026041835462454
2688 (t =   0.000030) -> 92397954424001202345470140259223339800545152366026986495210038576849968282449976165306588788229743102904475564792356498278345681858929732206168500576912729545514860498246613979334805607338853801253955941041959654713359486856789218572670461311628631887864270020874267394401237734664020976452439711261574143481444301202634061868362044860472092853948401599403563821252840765693473064539688735849359839306839923611146864435662475402634344715517206078884434600950521055152104529623466687658624496105500768894199291431669412057581037123291764216391191692726901655638058861528342571856571786801963359146447405423060735025111462013796941013497089339986734529524990254123285508407744451352247619155022764412184441707017214434555874720676155472011591167261744284255261412512202454657734960764468373352131556674296164300
2816 (t =   0.000010) -> 24502577402481463896501731384200002061795490268458940785996398338457734774349708943208472519175784247657089875235402295778074505022655857823461572092467596580653348938403653056944394747975633515900774989494382059011269514490315040046282544576679436798521313240840976146659949620947110461490311653655423164936301763031455885078405017585304836242622690330138431790905502335725583110444607640210609348217915984117735004588606879500832131186417518879222292060680090339919667476038257456314464044161061359390392769235486132868486686129182830083099176637349676965977329318029560744016523491159389393781584814957328810794232067413378135624241654301424908668448896093957376834587250058302822038446651037166100222898001288600891930364849873421596113588864093426244904834036545940765016180778135334497062341496704877622033187421247934924247182286478349346482
2944 (t =   0.000010) -> 3744811366942707934282677384980467582389144192711566379569120614799340374617054195857936387764857634104535260156081700709884039761725393602257387241856923551666889541381698305430206798119693912943138716238132758955830276884938847806688332036551637473756217570687208361221558762324150520753977044317052313618268571517036684001767615767200854123280815673091775442601271954265355188507689963979974056972433184636461036855490854525559435611406209909756531456642435956188025657873978377098506058473532058665760911151105365243682327213309118353942815015215062838682513660058662310603331164029619444834768490791737258393580500709378353868651528701505839634116435370683162057850405201556044757012125595723670621615177619728629654436806343389329102297388090947548573016458728874781439348323611306897786224605280567010798326784991857166721460151969998757244459476068559044322891545537347690385023
3072 (t =   0.000002) -> 1299073019258480880400779667055764694235357833489960203388525516466728598310704881278702912302075905774245759409071454211433863115473282214010386201837677638749082313810044401068834356858298213689341213944955132913004633885376580459434987158171917317818232747282111676627323045291523189341077415149999764991279608649899422864657642538957050904863423474794898193579308575739090748896209746080496381820610330653663639831159644538426610197180945383658336723125338256030965296596136650586594153545795889852464202896616398825416768797286490322620819671764731325254407772237677350425603740737897442479833690839815598505923282536095835284227341910461024462443969978386171807700108581466289769721274883395933432348483729280302815283085125531066827703100764913381379285864119443766254148104509410339007488936698766366002362952566769813579180782884965113726601142243757290615406609164951606676658068954377472310120395115645675956140219
3200 (t =   0.000010) -> 1910172615399215685593593778985773359198235910624552725226673995263224754381133383923551692466165360815829490047336636614796803984257222983529474118749120161360292616706182836910875003846255049600342709355325523365967595271924799866539303079616040775985706175204074677490329468453367012611354160187427275023983463683435087901165523649485730087261618429445769958441061977275898323440470812615853879722094888167517636334294790193581862794398336681521368933521848179861982647295751428155939664820399577073716815484822581657643179425161455889781753135127813057722452152095782142008013803678009839186382410113978542108787525615989111230511584730071942360763934207146012126491838500317019216446132181547005329672544689661357777611632006493138102278658307707756384061731003396479443056517286612852693469318250128060426261911302795853721544948116167926646663493171337249407590064807682333729245314238926629834628964718716504619871469223528106741489532366205939807944396759
3328 (t =   0.000011) -> 532221632151103563115348744850807143516832515904954709095235285061631021412289648961865554202742685642702444153790123435344855399417876892265217504886304314003336226221660284511200133768908011004701882285923028105593252700100660718329527561684629812390425929280465204160895812090783978928680108169024634817861879706366715654880788236982738347627482887414429404397841181684392824982465330867947911154679257681600362211958220336548677979691642084195003168272261867709860787438246606399583846267634070917786764544252648647406613497089052766043619655847913319944796165138614454435553512659003475608605518639433986271470066324764580135255118740039918427689905052442839364633030694960990406528028564338986986356708530279685002396922329050844684099779360972419616714940055972368683735344252135001027896159467018578498261941955671373856370196293115865446870544509775620097971946471391650190531398108222271884052196296464742631946737109604911076846088556140862544849960161840057294857164797932109227797376383930
3456 (t =   0.000023) -> 40073372781920421131763670452666632047333169321351522343007195036870193323056888709034687298041803342263981651436033948865750369078387852821414446725663201555695271367149300639436036207310421537937649725559475855627656033547680419114588271946968003893239757170388881670530934489804783993903915286807467120996520704694454814893012515355402860558364359020136967490401842612154655145704614580410045167758420035852079703796111715012801686952654924457889491470590186703181112305563776623743859929326571557319320169116170243872458029483317605605546832738945483767278485335773196005578928851328410334529461953865592191345391334506044794129045391109567487719151149067991624773767317145641705885346402680637065892259006334988390638732791872131707346247252147169456929341722774183472845380026810001072094531014976846033595114174681240765579919034241500714393038471556803650584064019780745185279001537141326596935556033461064548581672189572472025844216340684527910279161819951965667451330482427652688009668173730632904206971270561373322598727593662662
3584 (t =   0.000010) -> 20109273353137259512678703323696440557065867689333481709104978936817015273290581142481971020512607281517791160429715067363792648781174879503159320338901496782352586353274834508029516456467800861443399997252092231057720587207851341680885643029749787469690081845694325687435206877298276063538253630979846507942925856578750842253572297141719412308280401536366678153162780450895025880959308326341722690772757722197293956775837656377445230997838969542197797441869244894066100339411290044190064890169687875818401274403874481973969254366636311937424602508270674639996801198150705069731925124256806406173479321693545207336341815393942678704806065067120660083897312183529963232095058530011101991010573301412166243233845068895212848590105930979152952716331311088109121479159033295306686766420540385063920692400189005817450761738305008164271987387551315156375732813515380111083859882131071195714761417762501408282944761928427681108042315991794654671007308269642797688445820930849240784832886911469804917034695236950618145663401914529312447746478862608112037311772733124683450406495234645392
3712 (t =   0.000010) -> 11443070641775140691840362999472963012686760705347439017090515083684302849743235541633283816339297421021405623101384309715066448973905502257573231663557593729178139472620922929095427558135415335066341891998602475289953438503433380317401568669789399833426369689021447487931322319862028853278553406798170985808511836269585126137836259165796835994271074819810359123678147783345065712548500969871713641033939133479103688684173649286986092604000757197402413708080038336040225512666004329951862161559758760306897399909982648779090713176820129022741533565979923613679476946553147680311049260130106898476648395441827765293184317429283201426141905497649813381147766689591329346595934158353950391306951890107178857978747557903948233990450872708035484861833384766718941711228089785099001704288453210957199238646834340531782621830967543427931862085716175421998768784037177554342564761014780661968034792404027067423884146311367615139249123799025487550729267859265599906020779780905044505192418336546937750179020992613816676341848297906897188764781939124683416674770972301137914983943273683621462713718519693401276971935231484712451
3840 (t =   0.000009) -> 157435573747626907920531872697611592982951329158474203777284558712128479267929420333926972078594404409216685340623748896774903782495971853824037443635402033555990086753411615928225224180084306270461943002646636864441970171092712656968442202005919635049720528160642250757046491259524825025311922884717739308594799430333292665771402019814663966115286774863417212261859575584918841371138089007046477843127988343913059758308133650939505818825202182807079348473062785512709703765896396540069804267318212339285030865809243866121891502570080212434422590653329501842727883043121695658799157234138669924904762476389134479791735688769509600244282606507512770307461046468046853823941717296895966303727352244223001095000458004218463144943452125323955980504587842861906100212436495995613153489208895720250806155674806093585933145359470436941699259402826645291961913354518231955564185825799899049102620696642100018065749747052545781154771869071207607930184891548265791300866229603114446722134499746205085661386104517004336725005694923065497258282089777874125760397653218197561581234311293048421649092944046291011741088016835532558579408492929565424481669814426094409937
3968 (t =   0.000010) -> 697354940678946764152449650764177277799899300667290768930877862980610191418432403690407764512999600679720951537238134705961484224333665919296103771168700351741772244697394322532756150027016848281332330681136440947312445349972359387183101813221631436036462427756707758732903164349990251289434495598331414156631095398993425350701167321474136452009028331852586993081502813949918288773026101306648870643771005543141546442831417601665871074810115509159269790567471190869862992569371561420570933968887575240939889426687623420597120053547265943125531690561679535265791789613267588335745931846512452021432419661752512672814095501219085817389682009175222359935448728677941921309495492721689084387661393972020748318491418428170472120571490756167626865141267767734836156499689262609422168151247029258636901019531964526028006488827080535800012002741743391335391788976098897152094912382077937015339765041315774811036961331376245963477070683322711183818697944228527574366210407164267533492064112965455652536350022182574297516090035942141801584018949423625726439494059658133181302842914305872793333736138850386844904325738146690637048506039453511520932893319428844120181211128129173140232883318787981661759446
4096 (t =   0.000011) -> 658300225071601609288984519477937029957206459624491321423965954537895847373494653512389187162683482233822512702837752459516209377730799743737703673502517871364525114587043074700238126708737138901991839165992246209788890135411105889459254171793598118352288240057551012904611967947196358736805796703671931265196982929146115708048422524784565028434697041781111835727492866761525073162425408099088460782470079059458042674593101439620435445894575396749502461898706519585234750975469509836779821054768634389303844583109440376520320976008139990756734994284729635039877451599910210727634681437108418423500191690102405083353867999708519467612625730719215093192817128747553266903723952361169214961055440030411747248932641020486983298148814242038189001703004819084571653818033059448866802129017560880647220185535438807247451211959771481214237067791813455808086013144021877038631543907602192467430900021217976911934174840535986238731906637439014432247700159916234906817905415278969508617638193623745746464174121642630794058122492165969403547829509382628746301253860267182842952383793533781901149885496055629333264103301703665927148377682105632110309276081255125058037962832455900359119888108484745492916840821652824162266151376182280335742033648

Total Time: 0.001847
~~~~~~~~~~~~~~~

Observe na saída acima que o tempo de geração varia muito de uma execução para outra. Acreditamos que isto ocorre porque existem vários fatores envolvidos na execução, além do número de bits gerados, tais como o alinhamento de bytes nos registradores do processador para diferentes comprimentos em *bits* e também o próprio cache de memória.

Apesar da variação, a magnitude não varia muito, o que nos faz concluir que o tamanho dos números não influencia muito o desempenho de geração de números com o `xorshift+`. Seria interessante observar se esta correlação se mantém com outros métodos.

# Números Primos

Agora, que já sabemos como gerar os números aleatórios, vamos verificar se os números gerados são primos ou não.

Existem vários métodos disponíveis para verificar a *primalidade* de um número. Na próxima seção, vamos descrever e implementar o método de *Fermat*.

## O Método de *Fermat*

*Fermat* é um método simples que vai permitir determinar quão provavelmente um número é primo. Ou seja, este método não nos permite afirmar com certeza a *primalidade* (a não ser no casos de números muito pequenos), mas que a probabilidade é alta.

O algoritmo básico é seguinte:

- Dado um número *n* a ser verificado.
- Repita *k* vezes:
    - Gere um número aleatório entre [2, *n* − 2], chamado *a*.
    - Se $a^{n-1}\not\equiv1 \pmod n$, então *n* **não** é primo.
- Se $a^{n-1}\equiv1 \pmod n$ para todos valores gerados de *a*, então *n* **provavelmente** é primo.

Observe dois pontos importantes com relação ao método de *Fermat*:
1. Não há certeza de que *n* é primo, mas sim uma probabilidade.
2. Quanto maior o valor de *k*, maior a certeza de que *n* é primo.

Na seção abaixo, implementaremos *Fermat*.

## A Implementação

O código-fonte abaixo implementa a verificação de números primos usando *Fermat*:

~~~~~~~~~~~~~~~
// Gera um número aleatório dentro do intervalo determinado:
void random_mpz_interval(mpz_t rop, mpz_t min, mpz_t max)
{
    static const int base = 2;

    const size_t bit_count = mpz_sizeinbase(max, base);

    mpz_init(rop);
    do
    {
        mpz_clear(rop);
        random_mpz(rop, bit_count);
    }
    while ((mpz_cmp(rop, min) < 0) || (mpz_cmp(rop, max) > 0));
}

// Fermat
bool is_probably_prime(mpz_t op)
{
    // Define o valor de n:
    mpz_t n;
    mpz_init_set(n, op);
    mpz_abs(n, n);

    // Se n entre [1, 3], então número é primo:
    if (mpz_cmp_ui(n, 3) <= 0) return true;

    // Define o valor inferior do intervalo (min = 2):
    mpz_t min;
    mpz_init_set_ui(min, 2);

    // Define o valor superior do intervalo (max = n - 2):
    mpz_t max;
    mpz_init_set(max, n);
    mpz_sub_ui(max, max, 2);

    // Define valor do expoente:
    mpz_t exp;
    mpz_init_set(exp, n);
    mpz_sub_ui(exp, exp, 1);

    // Faz k = 5; repete 5 vezes:
    static const int k = 5;
    for (int i = 0; i < k; i++)
    {
        // Gera número dentro do intervalo pré-estabelecido:
        mpz_t a;
        random_mpz_interval(a, min, max);

        // Calcula o potência com mod:
        mpz_t r;
        mpz_init(r);
        mpz_powm(r, a, exp, n);

        // Se resultado != 1, então com certeza não é primo:
        if (mpz_cmp_ui(r, 1) != 0) return false;
    }

    // Após 5 testes, é provavelmente primo:
    return true;
}
~~~~~~~~~~~~~~~

Observe na listagem acima que usamos um valor de *k* baixo para minimizar o tempo de execução. Quando maior o valor de *k*, mais tempo leva a execução da função `is_probably_prime()`. Porém, um valor de *k* pequeno está aumentando as chances de um falso positivo. É necessário estabelecer uma boa relação entre desempenho e confiabilidade. Dependendo da aplicação, a confiabilidade pode ser mais importante que o desempenho, exigindo valores maiores de *k*.

Na função implementada abaixo, usamos a função `is_probably_prime()` para gerar números primos:

~~~~~~~~~~~~~~~
void find_prime(mpz_t rop, size_t bit_count)
{
    do
    {
        random_mpz(rop, bit_count);
        if (mpz_even_p(rop)) mpz_sub_ui(rop, rop, 1); // Verifica somente números ímpares.
    }
    while (!is_probably_prime(rop));
}
~~~~~~~~~~~~~~~

Observe que, dependendo do tamanho do número primo esperado (em *bits*), a execução da função `find_prime()` pode levar muito tempo executando até encontrar um número, dado que se está procurando números aleatoriamente. Para agilizar a procura, estamos procurando somente os números impares, visto que o único número par primo é o número 2.

## A Execução

O código-fonte abaixo gera números primos de 128 bits, 256, 512, e assim sucessivamente, até 4096 bits:

~~~~~~~~~~~~~~~
int main()
{
    static const int base = 10;
    static const size_t max_bit_count = 4096;
    static const size_t bit_count_inc = 128;

    const clock_t start = clock();

    size_t bit_count = bit_count_inc;
    while (bit_count <= max_bit_count)
    {
        const clock_t s = clock();

        mpz_t n;
        find_prime(n, bit_count);

        printf("%-4lu (t = %10.6lf)", bit_count, elapsed_secs(s));
        printf(" -> ");
        mpz_out_str(NULL, base, n);
        printf("\n");

        bit_count += bit_count_inc;
    }

    printf("\nTotal Time: %lf\n", elapsed_secs(start));

    return 0;
}
~~~~~~~~~~~~~~~

Abaixo, temos a execução do código listado acima:

~~~~~~~~~~~~~~~
28  (t =   0.000683) -> 324865934876219014188817636179210243083
256  (t =   0.006194) -> 79275113540127931976606952438131335816355767804964906054207541358214620762169
384  (t =   0.002596) -> 33663178916642404767972022482810007333992185114156844706578005824946283067754003019947382379169021598088266988096957
512  (t =   0.008433) -> 6978075481958970225533514553564411133610484390566161785769301445825198566407410617835683134056150689029169371320551942628830236008108870767526982841989083
640  (t =   0.146810) -> 4423755595021443879521191171814494528412136459701376771855280717778695982568137070488984140913275180567276035380895371425268432226288731617238963959778227855693503007023478697839647806413383817
768  (t =   0.474838) -> 1269435556431714073618151512144716869435128127654473280607865564776595604392328381173198459645671331138778702965155296696881606048095886529672034050989018315352187903111727433482084114804751092246039530240444039405804325045465677281
896  (t =   0.100969) -> 181367284184705782729019088045024916921476794614254597689216647061115745228175483213120876421990270570778746397228683296952118583410896582081104281305094003027443289667375612520910624786207069278739728754251830619254684770572008071778574985230559216615804948741058213669
1024 (t =   0.527501) -> 93562538680581046170347231209302190663047360199432574342730980851132373384727608989976039242503548126209683804591377459924935759519311207225277113371885662885168745258808617016172731890981776144549534460305537963312503097991229720080968614260593082907164603663956457716123827122219449214145302951462796849223
1152 (t =   0.841618) -> 34357800913989513999782265068337489542583288777377126045562611126398384799057057373605839305696264014207808722953319641864456156511676433879431683285647515842208998968506182851165290800019838530031070032650449574364081075649945809140814110536220313928651760696751824790937339262239998825403861469206515654002341463465352341210901420456379426653927
1280 (t =   0.113459) -> 19732738488984918692703888954445025235050051725530648607373173672716967155208182386291015604082901628422415243248221761361101141190598363734460755863608265804092903791794927429464513434801403090108715080847781701057097908337649117517969187995326487573943839197462528465538472575920618986067162428753474231373698901537082034287715658521610277229196518657424497747238066435630626053586081
1408 (t =   1.488586) -> 3199131537936147905992178053204559320651232566917789756472360149938363184716312572771302307732474725956186735652630475658252347666024827616584814489872921284388909229196636923622354214234528480464888439446692537550833733596778977001094035582661867557678280152693498216552798929299282794920613969507105983115114797340076428988751702886104067759914459896600274510883438689469234908409414669941098239305937554066331186469194353
1536 (t =   0.776068) -> 520366849736177342130336687736723495754754033183815304471214966907870162245024160182149280566452229215953985222578133368480376127738663266017659634451892333682386300690598704217789106316978163547426808584521037020761879937719375759413904034765951501189905221398060047871602039905108785353794728632485728220528984002168139881653833750216472569621878259720401879080312913422837623986756705927920736223236994375422485582515221947576361362601858100547827803468583839
1664 (t =   1.109293) -> 637416348329862916525663615102544012388131742707706920134266107387160867946884045186606149601272458742456561642263130316131408998309861345581121822671251922129828322967110351602165152103568655382709348428632429468035709027066226859973536382566875324462660166456307613580905046084500884277506113964553828238748274723498284371582939470790859506897119794778838735042366767584140851929070870161992114843278917740335313543843301371571874317372792627978184608551123100012067984152940645474173462772959299279
1792 (t =   9.877566) -> 10430741866691806361694828036960363453977466294957487113511331654694482858767734353847909512057538619375746781336958885319788318662939113600062834555415587586403860123177791068142656734232132895438662794529543446616386330467385627511025804404261913526960409970553005417052357031536802365455750981113430773577062529339129069262436374189032670394026118249860049628656944030540049890059905738888853696778926018265138770383966582754549057283891850943622250134319492211279977346252598637128179298263762903074793993004436843853602811833037819401
1920 (t =  18.682015) -> 84231003806056164519220097466885323735776311579120507866952586075928106407880869186079092961007182914061212019917540728025459162342807965502147269416133577485743605009830256320143003302031275990310935316235114570625785903751712967445758573942526703932838748208096987838930131316365954409109027214105632585889577823958313428161654949487762338580495781280412605915639644962322124174334850342898984554324976755280943915159460380189632088402673070278851869103393200178396069539193197261952516977300623722827868057652628770336213778146976670268515247081637955987509340981762068555837
2048 (t =   1.032783) -> 8025978000412898115870959418055867596418656343015678706435958884874478024357924903216182066766654041263386949591115091409336438995899446753317923321796363724047325753238926965290161433718537866834127566470532561801125640976861086825909912596340409025541436057818675425623458814491887401812383249891898296201068580989221973961267275862508469500095113494971977565911897189934494530302456795412547658476553574362783766401014262582167026620818364344680914013427951928609819274322994780707190396188761481243280475972800947297878115349885264681783604729391981481134986336023913427840136992623305611434925909658654018089439
2176 (t =   8.196905) -> 2309339950814787343021962087793561432720051163166020129829007280660066414731221809088713612062725733615748309876951844855675686516029246774627129689487812790425826455457940479881071006983495948364682122978732426962895117332758589603426690399250608360593200980330153598366390776589757499429520262707157317091813363771615176391462196905561692844525869102177428876837725848559977084954312069947499157218401873793237517376188645316235644644792786867329787681210485132230674771226212090612339203586854644579111938566144429899092435158499373337614982753589474396881710493465849173121339890304393588292902704386879470694441441905097038768952352039251887892443009
2304 (t =   8.954942) -> 745772192124897117527889494477299327884730143238498382298833152238492505103338031642668416878286595716239598777909059047294942698195502273523529847356472231186336183206141479488057000339331458689978937194721342050575733149992744755403280291759637540281484335273413663865644749704659777070826635314550986886611612776900057972344644162805995331126956204123529402100762397683578750847415538120496452296367014045958361407542055042598998299835882816589661055565289820410539483073406516485064801372788404902251562191550613753229061236408771936816204745546262490756167160129760439719542978314504476511455375369397277009924227151919992937016068460985405355645765560690698920349717280353545439681264381
2432 (t =  20.020598) -> 177911582052621635507615742933484046921160102889711116715428486093984556180804168464833233488461705397588809505648640926498738916656283944317830666586730423383388373383020261915822138925332278800557349595100229782208749795107919134678786095194343333985022823827131329868854809591620966239027171690690992963630621016230144839848184727347581568870008691893477269023821881734183351966527906050081969008671407193342180557029820661196957750698320343783568543794904766437552366287744449390276858361345016682710936309464570040490089044575829458357859329076008414151527825413472535428130930096803872829285096846436755670936720499109819422966176152279086061006208065344060511866373444158477339526556993527621585659853250223415420565829637531
~~~~~~~~~~~~~~~

Observe na saída acima que o maior número de bits impresso foi 2432; não foi 4096. Isto ocorre porque quanto maior o número, menor a probablidade de se encontrar um número primo, portanto mais iterações são necessárias, o que leva mais tempo.

A função geradora de números aleatórios também tem um efeito no desempenho. Observe que alguns números menores foram mais custosos que outros números maiores. Acreditamos que isto ocorra porque o gerador de números não é tão aleatório, dependendo do número de bits, o que torna mais difícil achar primos em determinadas sequencias. Seria interessante verificar o desempenho de outros métodos de geração de números, ou variações do mesmo método.

## *Miller-Rabin*

*Miller-Rabin* é uma extensão do método de *Fermat* que adiciona mais uma verificação:

$a^{2^rd} \equiv -1\pmod{n}$ para todo *r* no intervalo 0 ≤ r ≤ s − 1, onde *s* e *r* são positivos e *r* é impar.

Se *n* passa esta igualdade para todos os valores de *r*, então *n* é certamente um primo.

Devido a maior certeza do que no método de *Fermat*, este método é mais confiável para aplicações de criptografia.

# Conclusão

Os algoritmos de geração de números primos exigem muito computacionalmente do processador. Quanto maior o número a ser gerado, maior a quantidade de ciclos necessários para se encontrar um número primo. A escolha adequada do método pode aumentar a confiabilidade do número encontrado e também diminuir o tempo de processamento necessário.

Uma continuação interessante deste trabalho seria comparar os diferentes métodos e verificar seu desempenho e confiabilidade. Por exemplo, com a implementação de *Miller-Rabin* e também com a implementação de outros métodos de geração de números aleatórios.

<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden}</style>
<script src="markdeep.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

