<meta charset="utf-8" lang="pt">

                                    **Geração de Números Primos**
                                **INE5429 - Segurança em Computadores**
                                        Trabalho Individual #1
                                *Quenio Cesar Machado dos Santos (14100868)*
                                        Florianópolis, 08/05/2016

# Números Pseudo-Aleatórios

Uma sequência de números aleatórios pode ser gerada automaticamente por um computador. Existem algoritmos desenvolvidos para esta finalidade que são chamados de *geradores de números pseudo-aleatórios*.

As sequências resultantes destes geradores não são verdadeiramente aleatórias. Estas são geradas a partir de um grupo pequeno de valores iniciais - chamados sementes. Porém, alguns dos valores sementes podem ser verdadeiramente aleatórios. Por exemplo, eles podem originar-se do relógio do próprio computador ou ainda de ruídos da câmera de vídeo e do microfone.

O *período* dos algoritmos - o tamanho da sequência gerada sem repetição - também são normalmente muito longos. O que na prática permite a utilização destes algoritmos em aplicações que necessitam de uma fonte geradora de números aleatórios, tais como *criptografia*.

Existem vários métodos disponíveis para a implementação de geradores de números pseudo-aleatórios. Nas próximas seções, vamos utilizar um dos métodos para implementar um gerador na linguagem *C*. Esta linguagem de programação permite a operação de números de precisão variável - através da biblioteca *GMP* - e também gera código de máquina muito eficiente.

## Método

O método escolhido para a geração de números pseudo-aleatórios é `xorshift`. Este utiliza operações `XOR` e *bit-shift* para gerar novos números a partir de números anteriores.

Algoritmos implementados com `xorshift` executam muito rapidamente, pois utilizam operações implementadas por instruções do processador do computador que precisam de poucos *ciclos*. Entretanto, os parâmetros - valores sementes e constantes usados nas operações -  precisam ser escolhidos com cuidado para permitir longos períodos sem repetição de números.

Na sua forma original, o método `xorshift` não é adequado para uso em criptografia, pois não gera períodos muito longos. Mas este pode facilmente ser melhorado com o uso de uma operação de soma ou multiplicação. Estas variações são denominadas respectivamente de `xorshift+` e `xorshift*`.

Na próxima seção, vamos listar e comentar o código-fonte da implementação de `xorshift+` desenvolvida neste trabalho.

## Código-Fonte

O método `xorshift` exige uma sequência inicial de números - as sementes - a serem utilizadas para a geração dos números. Quanto maior o número de sementes, mais longo será o período do gerador.

Na implementação abaixo, utilizamos um vetor de 16 inteiros de 64 bits, que permite um período máximo de $2^{1024} - 1$:

~~~~~~~~~~~~~~~
static const size_t s_size = 16;
static const uint64_t seed[s_size] = {
    UINT64_C(3176816624292027912),
    UINT64_C(5825261852996363023),
    UINT64_C(2657966707352449287),
    UINT64_C(1350174793163142913),
    UINT64_C(3916890652982003621),
    UINT64_C(8441565361753670199),
    UINT64_C(4048287511883088063),
    UINT64_C(7692991216032604145),
    UINT64_C(9168990544929416867),
    UINT64_C(4210552781383542944),
    UINT64_C(1295553278952537540),
    UINT64_C(4600491088959978208),
    UINT64_C(1426091184381835091),
    UINT64_C(2349336915254555439),
    UINT64_C(2525507937445642803),
    UINT64_C(4828313259052508846)
};
~~~~~~~~~~~~~~~

Se utilizarmos as sementes tais quais elas foram definidas acima, nosso gerador irá sempre gerar a mesma sequência de números em cada nova execução do programa. Para tornar a sequência variável entre execuções, utilizados o relógio do computador para gerar novas sementes, como implementado abaixo:

~~~~~~~~~~~~~~~
void init_seed(uint64_t *s)
{
    for (int i = 0; i < s_size; i++)
    {
         s[i] = clock() + seed[i];
    }
}
~~~~~~~~~~~~~~~

Observe no código-fonte acima que o tempo em nanoseconds do relógio é somado ao valor inicial da semente para gerar uma nova semente, diferente em cada execução do programa. Estas novas sementes é que realmente serão utilizadas pelo algoritmo gerador, implementado a seguir:

~~~~~~~~~~~~~~~
// xorshift+ 1024-bit
uint64_t random_int64()
{
    // Posição atual no vetor de sementes:
    static size_t i = 0;

    // Inicializa sementes somente na primeira execução desta função:
    static uint64_t s[s_size];
    if (s[i] == 0) init_seed(s);

    // Estabelece os valores de semente a serem usados nesta geração:
    uint64_t s0 = s[i];
    uint64_t s1 = s[i = (i + 1) & (s_size - 1)];
    const uint64_t ps1 = s1;

    // Gera o novo número usando shifts e xor:
    s1 ^= s1 << 31;
    s[i] = s1 ^ s0 ^ (s1 >> 11) ^ (s0 >> 30);

    // Usa a soma para aumentar a aleatoriedade desta função:
    return s[i] + ps1;
}
~~~~~~~~~~~~~~~

Agora, a função implementada acima nos permite gerar sequências pseudo-aleatórias de inteiros de 64 bits. Para gerar números com maior número de bits, utilizamos este gerador e concatenamos seus números em números maiores:

~~~~~~~~~~~~~~~
static inline size_t div_ceiling(size_t op1, size_t op2)
{
    return 1 + ((op1 - 1) / op2);
}

void random_mpz(mpz_t rop, size_t bit_count)
{
    static const size_t byte_bit_count = 8;

    // Geração dos componentes do número:
    size_t size = div_ceiling(bit_count, byte_bit_count);
    size_t count = div_ceiling(size, sizeof(int64_t));
    uint64_t n[count];
    for (int i = 0; i < count; i++) n[i] = random_int64();

    // Se o número for maior que 64 bits, precisamos do vetor inteiro:
    static const size_t int64_bit_count = (sizeof(int64_t) * byte_bit_count);
    if (bit_count >= int64_bit_count)
    {
        mpz_init_set_int64(rop, count, n);
    }
    else
    {
        // Caso seja menos de 64 bits, capturamos apenas parte do número gerado:
        const size_t ignored_bits = (int64_bit_count - bit_count);
        mpz_init_set_ui(rop, n[0] >> ignored_bits);
    }
}
~~~~~~~~~~~~~~~


## Execução

# Números Primos

## Método

## Fermat versus Miller-Rabin

## Código-Fonte

## Execução

<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden}</style>
<script src="markdeep.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

